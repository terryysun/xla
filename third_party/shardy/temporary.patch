diff --git a/docs/sdy_dialect.md b/docs/sdy_dialect.md
index 8051d9c..72b3aa5 100755
--- a/docs/sdy_dialect.md
+++ b/docs/sdy_dialect.md
@@ -1101,39 +1101,36 @@ Syntax:
 A mesh is a list of axes and an optional list of device IDs specifying the
 device ordering.
 
-If the list of axes is empty
-  - If the `device_ids` is not provided, it is an empty mesh.
-  - If the `device_ids` is provided, it must be a single non-negative
-    integer, we call it a **maximal-sharding mesh**.
-
-If the list of axes is provided
-  - If a device ID list is specified, the product of the axis sizes should
-    match the number of devices.
-  - If a device ID list is not specified, the implicit device ID list is
-    iota(product(axes)). For simplicity, we also disallow specifying a
-    device ID list that is the same as iota(product(axes)); in this case, a
-    device ID list shouldn't be specified.
-  - It is not a maximal-sharding mesh even if the total size of axes is 1.
+If the list of axes is empty, the mesh has an implicit unnamed axis of
+size 1. In this case, if a device ID list is not provided, the implicit
+device ID list is [0]; if a device ID list is provided, it must
+contains a single integer of any non-negative value. We call this
+maximal-sharding case.
+
+For all non-maximal-sharding cases, if a device ID list is specified, the
+product of the axis sizes should match the number of devices. If a device ID
+list is not specified, the implicit device ID list is iota(product(axes)).
+For simplicity, we also disallow specifying a device ID list that is the
+same as iota(product(axes)); in this case, a device ID list shouldn't be
+specified.
 
 Here are some examples of meshes:
 
 - An empty mesh represents a placeholder mesh that can be replaced during
   propagation: <[]>
-- A mesh without axes list and a single non-negative device ID, which is a
-  maximal-sharding mesh: <[], device_ids=[3]>
+- A mesh with an unnamed axis and an explicit device ID, which is typically
+  used to represent maximal sharding: <[], device_ids=[3]>
 - A mesh with two axes and implicit device IDs iota(6): <["a"=2, "b"=3]>
 - A mesh with two axes and explicit device IDs specifying the device
   ordering: <["a"=3, "b"=2], device_ids=[0, 2, 4, 1, 3, 5]>
 
 **Constraints:**
-- Elements in `device_ids` should be non-negative.
-- If `axes` is empty, the size of `device_ids` can be 0 (empty mesh) or 1
-  (maximal-sharding mesh).
-- If `axes` is not empty,
-    - Elements in `axes` must not have duplicate names.
-    - If `device_ids` is specified, the original `device_ids` is not
-      `iota(product(axis_sizes))` and the sorted `device_ids` is
-      `iota(product(axis_sizes))`.
+- Elements in `axes` must not have duplicate names.
+- If `device_ids` is specified:
+  * The product of axis sizes must match the number of devices.
+  * All of its elements must be non-negative.
+  * `device_ids` should not be equal to `iota(product(axis_sizes))`.
+  * Sorted `device_ids` must be `iota(product(axis_sizes))`.
 
 #### Parameters:
 
diff --git a/shardy/dialect/sdy/ir/attrs.td b/shardy/dialect/sdy/ir/attrs.td
index cde47d2..5bca49c 100644
--- a/shardy/dialect/sdy/ir/attrs.td
+++ b/shardy/dialect/sdy/ir/attrs.td
@@ -54,39 +54,36 @@ def Sdy_Mesh : AttrDef<Sdy_Dialect, "Mesh"> {
     A mesh is a list of axes and an optional list of device IDs specifying the
     device ordering.
 
-    If the list of axes is empty
-      - If the `device_ids` is not provided, it is an empty mesh.
-      - If the `device_ids` is provided, it must be a single non-negative
-        integer, we call it a **maximal-sharding mesh**.
-
-    If the list of axes is provided
-      - If a device ID list is specified, the product of the axis sizes should
-        match the number of devices.
-      - If a device ID list is not specified, the implicit device ID list is
-        iota(product(axes)). For simplicity, we also disallow specifying a
-        device ID list that is the same as iota(product(axes)); in this case, a
-        device ID list shouldn't be specified.
-      - It is not a maximal-sharding mesh even if the total size of axes is 1.
+    If the list of axes is empty, the mesh has an implicit unnamed axis of
+    size 1. In this case, if a device ID list is not provided, the implicit
+    device ID list is [0]; if a device ID list is provided, it must
+    contains a single integer of any non-negative value. We call this
+    maximal-sharding case.
+
+    For all non-maximal-sharding cases, if a device ID list is specified, the
+    product of the axis sizes should match the number of devices. If a device ID
+    list is not specified, the implicit device ID list is iota(product(axes)).
+    For simplicity, we also disallow specifying a device ID list that is the
+    same as iota(product(axes)); in this case, a device ID list shouldn't be
+    specified.
 
     Here are some examples of meshes:
 
     - An empty mesh represents a placeholder mesh that can be replaced during
       propagation: <[]>
-    - A mesh without axes list and a single non-negative device ID, which is a
-      maximal-sharding mesh: <[], device_ids=[3]>
+    - A mesh with an unnamed axis and an explicit device ID, which is typically
+      used to represent maximal sharding: <[], device_ids=[3]>
     - A mesh with two axes and implicit device IDs iota(6): <["a"=2, "b"=3]>
     - A mesh with two axes and explicit device IDs specifying the device
       ordering: <["a"=3, "b"=2], device_ids=[0, 2, 4, 1, 3, 5]>
 
     **Constraints:**
-    - Elements in `device_ids` should be non-negative.
-    - If `axes` is empty, the size of `device_ids` can be 0 (empty mesh) or 1
-      (maximal-sharding mesh).
-    - If `axes` is not empty,
-        - Elements in `axes` must not have duplicate names.
-        - If `device_ids` is specified, the original `device_ids` is not
-          `iota(product(axis_sizes))` and the sorted `device_ids` is
-          `iota(product(axis_sizes))`.
+    - Elements in `axes` must not have duplicate names.
+    - If `device_ids` is specified:
+      * The product of axis sizes must match the number of devices.
+      * All of its elements must be non-negative.
+      * `device_ids` should not be equal to `iota(product(axis_sizes))`.
+      * Sorted `device_ids` must be `iota(product(axis_sizes))`.
   }];
   let parameters = (ins
       OptionalArrayRefParameter<"MeshAxisAttr", "mesh axes">:$axes,
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 509398d..75d72f7 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1 +1,12 @@
 Auto generated patch. Do not edit or delete it, even if empty.
+diff -ruN --strip-trailing-cr a/mlir/include/mlir/Interfaces/ControlFlowInterfaces.h b/mlir/include/mlir/Interfaces/ControlFlowInterfaces.h
+--- a/mlir/include/mlir/Interfaces/ControlFlowInterfaces.h
++++ b/mlir/include/mlir/Interfaces/ControlFlowInterfaces.h
+@@ -18,7 +18,6 @@
+ #include "mlir/IR/Operation.h"
+ #include "llvm/ADT/PointerUnion.h"
+ #include "llvm/ADT/STLExtras.h"
+-#include "llvm/Support/DebugLog.h"
+ #include "llvm/Support/raw_ostream.h"
+ 
+ namespace mlir {
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 35aaef5..655dc54 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "29c830cbf8c65fcab7f96f92c8466cbcc9924dd1"
-    LLVM_SHA256 = "a717cad48a81fcc96b310e5bd953a20c8c569a08e2a95594206bd8900a1df32d"
+    LLVM_COMMIT = "028bfa255e90581d1c08237a66c20b25096277e8"
+    LLVM_SHA256 = "b1e5fbb1ed51e8e22e1ecdf0d74e7b28b1c554bb507326df2172c0c4707de0f8"
 
     tf_http_archive(
         name = name,
